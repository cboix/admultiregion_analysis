#!/usr/bin/R
# -------------------------------------------------------------
# Bin cells with top scores - pseudotime ish
# Updated: 12/06/2021
# -------------------------------------------------------------
library(cbrbase)
set_proj('DEVTRAJ', 'multiRegion')
source(paste0(sbindir, 'load_metadata.R'))

library(tidyr)
library(viridis)
library(ggplot2)
library(ggrepel)
library(ggpubr)
library(ggpmisc)
library(patchwork)

library(ComplexHeatmap)
library(circlize)

# Directories:
pstdir = paste0(sdbdir, 'pst/')
regdir = paste0(sdbdir, 'dereg/')
plotdir = paste0(imgdir, 'vuln/')
imgpref = paste0(plotdir, 'ecDE_')
cmd = paste('mkdir -p', plotdir)
system(cmd)


# Load everything (including full matrix dataset):
# ------------------------------------------------
commandArgs <- function(trailingOnly=TRUE){c(TRUE, TRUE, TRUE)}
source(paste0(sbindir, 'neuronal_vulnerability/load_EC_data.R'))

# Metadata for the pseudobulk matrix:
umeta = ps.data$meta
pmat = ps.data$mat
umeta = umeta[umeta$cell_type_high_resolution != 'Exc SOX11 NCKAP5',]
umeta = umeta[umeta$ncell > 10,]


# Matched metadata to the full matrix:
# ------------------------------------
rownames(cellmeta) = cellmeta$barcode
submeta = cellmeta[colnames(nmat),]
advars = c('cogdx','cogdxad','niareagansc','nrad','braaksc')
covars = c('age_death','msex','pmi', 'Apoe_e4')
submeta = merge(submeta, unique(metadata[,c('projid','region', advars, covars)]))
rownames(submeta) = submeta$barcode
submeta = submeta[colnames(nmat),]


# Load in regression results for subtypes:
# ----------------------------------------
topdeg.file = paste0(regdir, 'allmethods.vulnerable_excitatory_subsets.bypath.tsv.gz')
topdegdf = read.delim(gzfile(topdeg.file), sep="\t")
topdegdf = topdegdf[order(topdegdf$log10p_nm, decreasing=T),]
upgene = unique(topdegdf$gene[topdegdf$col == 2])
dwgene = unique(topdegdf$gene[topdegdf$col == 1])


# Read in scores from EC_DEGs_03_score_cells.R
# --------------------------------------------
ecscore.file = paste0(regdir, 'DE_score_table_EC.tsv.gz')
ecscoredf = read.delim(gzfile(ecscore.file), sep="\t") 

# Aggregate score; not diffuse plaque because it's not a great predictor
aggscoredf = aggregate(cbind(upz, dwz) ~ barcode, ecscoredf[ecscoredf$path != 'plaq_d',], mean)



# Bin cells on zscores:
breaks = (-2, 1, 0, 1, 2, 3)
aggscoredf$up.bin = cut(aggscoredf$upz, breaks=breaks)


# TODO: UMAP from markers?
aggscoredf$raw = apply(log1p(nmat[upgene, aggscoredf$barcode]), 2, mean)

# Plot some scores first:
# gene = 'MT-ND3'
# gene = 'CDK5R1'
# gene = 'PRNP'
gene = 'CLU'
gene = 'HLF'
aggscoredf$x = log1p(nmat[gene, aggscoredf$barcode])

ggplot(aggscoredf, aes(upz, x)) + 
    geom_point() + geom_smooth(method='gam') + 
    theme_pubr()


# Using tradeSeq and our simple pseudotime, ID genes along trajectory:
# --------------------------------------------------------------------
library(tradeSeq)

# Fit the actual GAM model:
scefit.rda = paste0(pstdir,'EC_DEscore_dpt_GAMfit_dataset.Rda')
if (!file.exists(scefit.rda)){
    pseudotime = matrix(aggscoredf$upz)
    cellWeights = matrix(rep(1, nrow(aggscoredf)), ncol=1, dimnames=list(aggscoredf$barcode, NULL))
    # Takes about 2hrs (did on original... full?)  
    # 5-6 minutes for 350 up genes
    # ~ 4-5 hours on the full dataset?
    sce <- fitGAM(counts = nmat[upgene, aggscoredf$barcode],
                  pseudotime = pseudotime,
                  cellWeights = cellWeights)

    # Simple association test to see which genes 
    # are associated with the pseudotime:
    resdf <- associationTest(sce)
    resdf = resdf[order(resdf$pvalue),]
    head(resdf)

    # Save results
    save(sce, resdf, file=scefit.rda)
} else { 
    load(scefit.rda)
}



# Plot the differential genes? Cluster them? Heatmap too.
resdf$gene = rownames(resdf)
resdf$padj = p.adjust(resdf$pvalue, 'fdr')
resdf$padj[is.na(resdf$padj)] = 1

# Get top genes:
p.cutoff = 1e-5
logFC.cutoff = .25
keep.genes = resdf$gene[resdf$padj < p.cutoff & resdf$meanLogFC > logFC.cutoff]
print(length(keep.genes))
pdf = predictSmooth(sce, gene=keep.genes)
# Matrix from this:
pdf = merge(pdf, data.frame(time=unique(pdf$time), pos=1:100))
pwide = spread(pdf[,c('gene','yhat','pos')], pos, yhat)
pmat = as.matrix(pwide[,-1])
rownames(pmat) = pwide$gene

# Only genes past some max
sm.cut = 0.1
pmat = pmat[apply(pmat, 1, max) > sm.cut,]
print(dim(pmat))

# # Some of these will be fixed labeling:
# labgenes = sort(unique(c('Cst3','Fth1', 'Cdkn1a','Ubb','Lig1','Hjurp','Exoc4'))
# labgenes = labgenes[labgenes %in% rownames(pmat)]

# Plot as annotated heatmap:
# pltmat = pmat
pltmat = t(scale(t(pmat)))
pltmat[pltmat > 10] = 10
pltmat = reord(pltmat, measure='euclidean', method='ward.D')
# pltmat = reord(pltmat, measure='cosine', method='ward.D')

# Predict peak location for ordering:
centmat = sweep(pltmat,1,apply(pltmat, 1, min),'-')
centmat = sweep(centmat,1,apply(centmat, 1,sum),'/')
centmat = sweep(centmat,2,1:100,'*')
centind = apply(centmat,1,sum)
pltmat = pltmat[order(apply(pltmat, 1, which.max), decreasing=T),]

rownames(meta) = meta$cell
mind = apply(pltmat, 1, which.max)
# Get which is top cell here:
ptime = sort(unique(pdf$time))
ctlab = sapply(mind, function(x){
                   dt = head(sort(abs(traj$cds$dpt_pseudotime - ptime[x])), 10)
                   tab = table(meta[names(dt), 'sublabel2'])
                   names(which.max(tab))[1] })


pvalue_col_fun = colorRamp2(c(0, 2, 3), c("green", "white", "red")) 
plasma.col_fun = colorRamp2(ptime, plasma(100))

# Gene annotation:
lat = sapply(labgenes, function(x){which(rownames(pltmat) == x)})
ha = rowAnnotation(Pseudotime= anno_simple(ptime[mind], col = plasma.col_fun),
                   Label=ctlab,
                   foo = anno_mark(at=lat, labels = labgenes),
                   col = list(Label=sublabel.col))

hb1 = HeatmapAnnotation(Pseudotime= anno_simple(ptime, col = plasma.col_fun))

Heatmap(pltmat, name = "GAM\n(scaled)", # col=viridis(100),
        cluster_rows = FALSE, 
        cluster_columns=FALSE,
        # top_annotation=hb1,
        # right_annotation = ha,
)
# show_column_names=FALSE,
# show_row_names=FALSE)








# Identify cells on the tail end of the distribution:
# ---------------------------------------------------
zcut = 2
topup = aggscoredf$barcode[aggscoredf$upz > zcut]
topdw = aggscoredf$barcode[aggscoredf$dwz < -zcut]
sum(topup %in% topdw)  # About half of down cells are in the up-reg set too.







